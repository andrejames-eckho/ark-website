-- Fix admin security vulnerability by replacing user_metadata references
-- This migration creates a secure admin role system and updates RLS policies

-- Step 1: Create secure admin_roles table
CREATE TABLE IF NOT EXISTS admin_roles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  role TEXT NOT NULL DEFAULT 'admin' CHECK (role IN ('admin')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id),
  UNIQUE(user_id)
);

-- Step 2: Create secure admin check function
CREATE OR REPLACE FUNCTION is_admin_user()
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Check if current user is in admin_roles table
  RETURN EXISTS (
    SELECT 1 FROM admin_roles 
    WHERE user_id = auth.uid()
  );
END;
$$;

-- Step 3: Drop existing insecure policies if they exist
DROP POLICY IF EXISTS "Admin delete access" ON equipment;
DROP POLICY IF EXISTS "Admin insert access" ON equipment;
DROP POLICY IF EXISTS "Admin update access" ON equipment;

-- Step 4: Create secure admin policies
CREATE POLICY "Admins can insert equipment" ON equipment
FOR INSERT WITH CHECK (is_admin_user());

CREATE POLICY "Admins can update equipment" ON equipment
FOR UPDATE USING (is_admin_user());

CREATE POLICY "Admins can delete equipment" ON equipment
FOR DELETE USING (is_admin_user());

-- Step 5: Migrate existing admin users from user_metadata
-- This finds users with admin role in user_metadata and moves them to secure system
INSERT INTO admin_roles (user_id, created_by)
SELECT 
  id as user_id,
  id as created_by
FROM auth.users 
WHERE raw_user_meta_data->>'role' = 'admin'
ON CONFLICT (user_id) DO NOTHING;

-- Step 6: Create helper function for admin management
CREATE OR REPLACE FUNCTION grant_admin_role(target_user_id UUID, granting_user_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Only existing admins can grant new admin roles
  IF NOT EXISTS (SELECT 1 FROM admin_roles WHERE user_id = granting_user_id) THEN
    RAISE EXCEPTION 'Only existing admins can grant admin roles';
  END IF;
  
  INSERT INTO admin_roles (user_id, created_by)
  VALUES (target_user_id, granting_user_id)
  ON CONFLICT (user_id) DO NOTHING;
  
  RETURN true;
END;
$$;

-- Step 7: Create helper function for admin role removal
CREATE OR REPLACE FUNCTION revoke_admin_role(target_user_id UUID, revoking_user_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Only existing admins can revoke admin roles (except self)
  IF NOT EXISTS (SELECT 1 FROM admin_roles WHERE user_id = revoking_user_id) THEN
    RAISE EXCEPTION 'Only existing admins can revoke admin roles';
  END IF;
  
  DELETE FROM admin_roles WHERE user_id = target_user_id;
  RETURN true;
END;
$$;

-- Step 8: Add RLS to admin_roles table (only admins can see/manage)
ALTER TABLE admin_roles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can view admin roles" ON admin_roles
FOR SELECT USING (is_admin_user());

CREATE POLICY "Admins can insert admin roles" ON admin_roles
FOR INSERT WITH CHECK (is_admin_user());

CREATE POLICY "Admins can delete admin roles" ON admin_roles
FOR DELETE USING (is_admin_user());

-- Step 9: Create view for easy admin checking
CREATE OR REPLACE VIEW admin_users AS
SELECT 
  u.id,
  u.email,
  u.created_at as user_created_at,
  ar.created_at as admin_since,
  ar.created_by
FROM auth.users u
JOIN admin_roles ar ON u.id = ar.user_id;
